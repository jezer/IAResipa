# 01. Atividades de Implementação - Organização do Fluxo

## 1. Visão Geral

Este documento detalha as atividades de desenvolvimento para estruturar o fluxo de conversação usando LangGraph e implementar o gerenciamento de memória com Supabase. O objetivo é criar a espinha dorsal da aplicação que orquestra a lógica de negócio.

## 2. Atividades

### Atividade 1: Definição do Estado do Grafo (`ReservationState`)

-   **Descrição:** Definir a classe `TypedDict` que representará o estado da nossa conversa (`ReservationState`).
-   **Campos Iniciais:**
    -   `user_message: str`
    -   `phone_number: str`
    -   `intent: str`
    -   `sql_query: str`
    -   `sql_result: dict`
    -   `response: str`
    -   `user_id: int`
    -   `is_registered: bool`
    -   (Adicionar outros campos conforme a necessidade evolui)
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:** A classe `ReservationState` está definida e importada corretamente para uso no grafo.

### Atividade 2: Estrutura do Grafo (Nós e Arestas)

-   **Descrição:** Instanciar o `StateGraph` e adicionar os nós principais e as arestas que definem o fluxo da conversa.
-   **Nós Principais:**
    -   `classify_intent`
    -   `check_user`
    -   `execute_sql` (ou nós de lógica de negócio específicos por intenção)
    -   `format_response`
-   **Arestas:**
    -   Definir o ponto de entrada (`entry_point`) para `classify_intent`.
    -   Conectar os nós sequencialmente.
    -   Implementar arestas condicionais (`conditional_edges`) para rotear o fluxo com base no estado (ex: `is_registered`, `intent`).
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:** O grafo é compilado (`workflow.compile()`) sem erros e a lógica de roteamento funciona conforme o fluxograma.

### Atividade 3: Implementação do Nó de Verificação de Usuário (`check_user`)

-   **Descrição:** Criar a função que verifica se o usuário está cadastrado no Supabase.
-   **Lógica:**
    1.  Receber o `state`.
    2.  Consultar a tabela `cadastro_pessoas_fisica` no Supabase usando o `phone_number` do estado.
    3.  Atualizar o `state` com `is_registered=True` e `user_id` se o usuário for encontrado.
    4.  Se não for encontrado, atualizar `is_registered=False` e definir uma resposta direta no `state['response']` informando sobre a necessidade de cadastro.
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:** O estado é atualizado corretamente com base na existência do usuário no banco de dados.

### Atividade 4: Implementação do Nó de Execução de Lógica (`execute_sql`)

-   **Descrição:** Criar um nó genérico para executar as consultas SQL geradas pelo passo de classificação de intenção.
-   **Lógica:**
    1.  Receber o `state`.
    2.  Verificar se existe um `sql_query` no estado.
    3.  Executar a consulta no Supabase (preferencialmente via uma função RPC segura `execute_sql`).
    4.  Armazenar o resultado da consulta em `state['sql_result']`.
    5.  Implementar tratamento de erro para falhas na execução da consulta.
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:** As consultas SQL são executadas com sucesso e o resultado é salvo no estado.

### Atividade 5: Implementação da Memória de Longo Prazo (Supabase)

-   **Descrição:** Desenvolver a lógica para persistir e recuperar o estado da conversa no Supabase.
-   **Lógica:**
    1.  **Salvar Estado:** Criar uma função que serialize o `ReservationState` para JSON e o salve na tabela `conversational_memory` associado ao `phone_number`.
    2.  **Carregar Estado:** No início do fluxo, criar uma função que consulte a tabela `conversational_memory` por um estado recente para o `phone_number` do usuário.
    3.  **Integração:** Modificar a função principal (`process_message`) para chamar a função de carregar estado no início e a de salvar estado no final da execução do grafo.
    4.  **Definir Tabela:** Criar o script SQL ou usar a interface do Supabase para criar a tabela `conversational_memory` (colunas: `id`, `phone_number`, `state_json`, `last_updated_at`).
-   **Arquivos Afetados:** O script principal e um novo arquivo de setup do banco de dados (se necessário).
-   **Critérios de Aceitação:**
    -   O estado da conversa é salvo no Supabase após cada interação.
    -   Uma conversa interrompida pode ser retomada com o contexto anterior ao receber uma nova mensagem do mesmo usuário.
