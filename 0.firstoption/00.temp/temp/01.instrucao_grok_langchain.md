leia o gemini.md para garantir que está com as instruções basicas em memoria

observe estas instruções abaixo,
1. Leia os textos abaixo
2. Depois Leia os textos em : C:\source\IAResipa\02.docs\06.interpretartexto\03.objetivo para identificar melhorias
3. e então vamos criar uma serie de atividades para uma nova versão em em duas novas pastas : C:\source\IAResipa\02.docs\07.organizacaofluxo e C:\source\IAResipa\02.docs\08.responderaoUsuario
4.  onde o 07.organizacaofluxo o foco é a organização das etapas, estados para o objetivo de um cenario
5.  e o 08.responderaoUsuario o foco é como entender o que responder, pela memoria anteriores e pelas informações enviadas pelo 07.organizacaofluxo ao 08.responderaoUsuario


   então como resultado teremos documentos de objetivo dividido em duas pastas: 07.organizacaofluxo e 08.responderaoUsuario
   e os objetivos serão revisados e melhorando os objetivos anteriores da pasta : 06.interpretartexto

   então o objetivo é apenas gerar os arquivos de documetação pasta 03.objetivo nas duas pastas: 07.organizacaofluxo e 08.responderaoUsuario, que irá então permitir se ocupar nas demais

    não vamos fazer nada da pasta: 04.activities e nem da 05.scenarios de ambos.

então siga as instruções abaixo:

### Visão Geral da Solução
Para criar uma solução em Python para lidar com mensagens relacionadas a reservas usando LangChain, LangGraph e LangSmith, enquanto aproveitamos a API do Gemini para respostas inteligentes, focarei em receber mensagens de usuários, processá-las e gerar respostas. A solução ignorará a integração com o WhatsApp e se concentrará exclusivamente na lógica de processamento de mensagens e geração de respostas. O sistema usará o LangChain para interagir com o Gemini, o LangGraph para gerenciar o fluxo de conversa e o LangSmith para observabilidade e depuração.

### Resumo da Solução
- **LangChain**: Usado para integrar com a API do Gemini (via ChatGemini) para processar mensagens de usuários e gerar respostas inteligentes.
- **LangGraph**: Gerencia o fluxo de conversa com estado, lidando com intenções do usuário (por exemplo, verificar disponibilidade, fazer reserva, cancelar, etc.) e roteando para ações apropriadas.
- **LangSmith**: Fornece observabilidade para depuração e monitoramento do fluxo de conversa e interações com o LLM.
- **Foco**: Receber mensagens de texto, interpretar intenções, consultar um banco de dados Supabase (com esquema assumido com base nos documentos fornecidos) e responder adequadamente usando o Gemini.

### Pressupostos
Com base nos documentos fornecidos, assumirei o seguinte:
- Um banco de dados Supabase com as tabelas:
  - `cadastro_pessoas_fisica` (colunas: `id`, `phone_number`, `name`)
  - `quiosques` (colunas: `id`, `name`, `capacity`, `location`)
  - `quadras_beach_tennis` (colunas: `id`, `name`, `court_type`, `lighting`)
  - `reservas` (colunas: `id`, `id_pessoa`, `id_recurso`, `tipo_recurso`, `data_hora_inicio`, `data_hora_fim`, `status`, `valor`, `pix_id`)
  - `lista_espera` (colunas: `id`, `id_pessoa`, `id_recurso`, `tipo_recurso`, `data_hora_solicitacao`)
- As mensagens dos usuários são baseadas em texto e recebidas por uma interface hipotética (por exemplo, uma função ou API em Python).
- A API do Gemini será usada para interpretar intenções dos usuários e gerar consultas SQL ou respostas.
- O processamento de pagamentos (Pix) e a integração com o WhatsApp estão fora do escopo.

### Componentes da Solução
1. **Integração com LangChain e Gemini**:
   - Usar `ChatGemini` para processar mensagens dos usuários e gerar respostas ou consultas SQL.
   - Modelos de prompt guiarão o Gemini para classificar intenções e gerar consultas SQL apropriadas para o Supabase.

2. **LangGraph para Fluxo de Conversa**:
   - Uma máquina de estados para gerenciar a conversa, incluindo:
     - Verificação do usuário (verificar se o número de telefone está registrado).
     - Classificação de intenções (por exemplo, verificar disponibilidade, reservar, cancelar).
     - Consultas ao banco de dados e formatação de respostas.
   - O estado rastreará detalhes do usuário, contexto da conversa e intenção.

3. **LangSmith para Observabilidade**:
   - Configurar o LangSmith para registrar interações, chamadas ao LLM e erros para depuração.

4. **Cliente Supabase**:
   - Usar a biblioteca `supabase-py` para interagir com o banco de dados.

5. **Lógica Principal**:
   - Um script Python que recebe uma mensagem do usuário e número de telefone, processa por meio do LangGraph e retorna uma resposta.

### Implementação

```python
```python
import os
from uuid import uuid4
from typing import TypedDict, Annotated
from langchain_core.prompts import ChatPromptTemplate
from langchain_Gemini import ChatGemini
from langgraph.graph import StateGraph, END
from supabase import create_client, Client
from datetime import datetime
import json

# Variáveis de ambiente (defina no seu ambiente ou arquivo .env)
os.environ["LANGSMITH_API_KEY"] = "sua_chave_api_langsmith"
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_PROJECT"] = "SistemaReservas"
os.environ["Gemini_API_KEY"] = "sua_chave_api_Gemini"
os.environ["SUPABASE_URL"] = "sua_url_supabase"
os.environ["SUPABASE_KEY"] = "sua_chave_supabase"

# Cliente Supabase
supabase: Client = create_client(os.environ["SUPABASE_URL"], os.environ["SUPABASE_KEY"])

# Modelo LangChain Gemini
llm = ChatGemini(model="Gemini-3", api_key=os.environ["Gemini_API_KEY"])

# Prompt para classificação de intenção e geração de SQL
intent_prompt = ChatPromptTemplate.from_template("""
Você é um assistente de sistema de reservas. Com base na mensagem do usuário, classifique a intenção e gere uma resposta ou consulta SQL conforme necessário.

Mensagem do Usuário: {user_message}
Número de Telefone do Usário: {phone_number}

Intenções possíveis:
1. check_user: Verificar se o usuário está registrado.
2. check_availability: Verificar disponibilidade de quiosques ou quadras de beach tennis.
3. make_reservation: Criar uma reserva para um quiosque ou quadra.
4. cancel_reservation: Cancelar uma reserva existente.
5. check_reservations: Visualizar as reservas ativas do usuário.
6. join_waitlist: Entrar na lista de espera para um recurso.
7. general_query: Lidar com perguntas gerais ou intenções desconhecidas.

Instruções:
- Para check_user, gere uma consulta SQL para verificar se o phone_number existe em cadastro_pessoas_fisica.
- Para check_availability, gere uma consulta SQL para encontrar quiosques ou quadras disponíveis para uma data/hora específica.
- Para make_reservation, gere uma consulta SQL para criar uma reserva provisória.
- Para cancel_reservation, gere uma consulta SQL para cancelar uma reserva e verificar a lista de espera.
- Para check_reservations, gere uma consulta SQL para listar as reservas ativas do usuário.
- Para join_waitlist, gere uma consulta SQL para adicionar o usuário à lista de espera.
- Para general_query, forneça uma resposta em linguagem natural ou peça esclarecimentos.

Retorne um objeto JSON com:
- intent: A intenção classificada
- sql_query: A consulta SQL (se aplicável)
- response: A resposta para o usuário (se nenhuma consulta SQL for necessária)

Exemplo:
{
  "intent": "check_user",
  "sql_query": "SELECT * FROM cadastro_pessoas_fisica WHERE phone_number = '123456789'",
  "response": null
}
""")

# Definição do estado para LangGraph
class ReservationState(TypedDict):
    user_message: str
    phone_number: str
    intent: str
    sql_query: str
    sql_result: dict
    response: str
    user_id: int
    is_registered: bool

# Nó para classificar intenção
async def classify_intent(state: ReservationState) -> ReservationState:
    prompt = intent_prompt.format(
        user_message=state["user_message"],
        phone_number=state["phone_number"]
    )
    result = await llm.ainvoke(prompt)
    try:
        parsed = json.loads(result.content)
        return {
            "intent": parsed["intent"],
            "sql_query": parsed.get("sql_query"),
            "response": parsed.get("response")
        }
    except json.JSONDecodeError:
        return {"intent": "general_query", "response": "Desculpe, não entendi sua solicitação. Pode esclarecer?"}

# Nó para verificar registro do usuário
async def check_user(state: ReservationState) -> ReservationState:
    if state["intent"] != "check_user" or not state["sql_query"]:
        return state
    try:
        result = supabase.table("cadastro_pessoas_fisica").select("*").eq("phone_number", state["phone_number"]).execute()
        if result.data:
            return {
                "user_id": result.data[0]["id"],
                "is_registered": True,
                "response": "Usuário encontrado. Como posso ajudar com sua reserva?"
            }
        else:
            return {
                "is_registered": False,
                "response": "Seu número não está cadastrado. Entre em contato com um administrador para se cadastrar."
            }
    except Exception as e:
        return {"response": f"Erro ao verificar cadastro: {str(e)}"}

# Nó para executar consultas SQL
async def execute_sql(state: ReservationState) -> ReservationState:
    if not state["sql_query"] or state["intent"] in ["check_user", "general_query"]:
        return state
    try:
        result = supabase.rpc("execute_sql", {"query": state["sql_query"]}).execute()
        return {"sql_result": result.data}
    except Exception as e:
        return {"response": f"Erro ao executar consulta: {str(e)}"}

# Nó para formatar resposta
async def format_response(state: ReservationState) -> ReservationState:
    if state["response"]:
        return state
    if state["sql_result"]:
        prompt = ChatPromptTemplate.from_template("""
        Formate o resultado SQL a seguir em uma resposta amigável para o usuário.

        Intenção: {intent}
        Resultado SQL: {sql_result}

        Forneça uma resposta clara e concisa em português.
        """).format(intent=state["intent"], sql_result=state["sql_result"])
        result = await llm.ainvoke(prompt)
        return {"response": result.content}
    return {"response": "Desculpe, não consegui processar sua solicitação. Tente novamente."}

# Definir o grafo
workflow = StateGraph(ReservationState)

# Adicionar nós
workflow.add_node("classify_intent", classify_intent)
workflow.add_node("check_user", check_user)
workflow.add_node("execute_sql", execute_sql)
workflow.add_node("format_response", format_response)

# Definir arestas
workflow.set_entry_point("classify_intent")
workflow.add_edge("classify_intent", "check_user")
workflow.add_conditional_edges(
    "check_user",
    lambda state: "execute_sql" if state["is_registered"] and state["sql_query"] else "format_response",
    {"execute_sql": "execute_sql", "format_response": "format_response"}
)
workflow.add_edge("execute_sql", "format_response")
workflow.add_edge("format_response", END)

# Compilar o grafo
graph = workflow.compile()

# Função principal para processar uma mensagem do usuário
async def process_message(user_message: str, phone_number: str) -> str:
    initial_state = {
        "user_message": user_message,
        "phone_number": phone_number,
        "intent": "",
        "sql_query": "",
        "sql_result": {},
        "response": "",
        "user_id": 0,
        "is_registered": False
    }
    result = await graph.ainvoke(initial_state)
    return result["response"]

# Exemplo de uso
if __name__ == "__main__":
    import asyncio
    async def main():
        # Mensagens de exemplo
        messages = [
            ("Quero verificar a disponibilidade de quadras para amanhã às 14h", "+5511999999999"),
            ("Quero cancelar minha reserva com ID 123", "+5511999999999"),
            ("Quais reservas eu tenho?", "+5511999999999")
        ]
        for msg, phone in messages:
            response = await process_message(msg, phone)
            print(f"Usuário: {msg}\nResposta: {response}\n")
    asyncio.run(main())
```

### Explicação do Código
- **Configuração do Ambiente**: O script espera variáveis de ambiente para LangSmith, API do Gemini e credenciais do Supabase. Substitua os placeholders pelos valores reais.
- **LangChain**: O modelo `ChatGemini指標` é usado com um prompt para classificar intenções e gerar consultas SQL ou respostas. O prompt é projetado para lidar com várias intenções com base nos fluxos dos documentos fornecidos (por exemplo, 09.1, 09.2, 09.6).
- **LangGraph**: Uma máquina de estados gerencia o fluxo de conversa:
  - `classify_intent`: Usa o Gemini para determinar a intenção do usuário e gerar uma consulta SQL ou resposta.
  - `check_user`: Verifica se o número de telefone do usuário está registrado em `cadastro_pessoas_fisica`.
  - `execute_sql`: Executa consultas SQL no Supabase (assume uma função RPC `execute_sql` para segurança).
  - `format_response`: Formata resultados SQL em respostas amigáveis usando o Gemini.
- **LangSmith**: Habilitado por meio de variáveis de ambiente para rastreamento e depuração de chamadas ao LLM e execução do grafo.
- **Supabase**: Interage com o banco de dados usando o cliente `supabase-py`. Assume uma configuração de execução de SQL segura.
- **Função Principal**: A função `process_message` recebe uma mensagem do usuário e número de telefone, processa pelo grafo e retorna uma resposta.

### Notas
- **Esquema do Banco de Dados**: O código assume os nomes de tabelas e colunas dos documentos fornecidos. Você precisará confirmar ou ajustar as consultas SQL no prompt.
- **Supabase RPC**: O script assume uma função RPC `execute_sql` para execução segura de consultas. Você pode precisar configurar isso no Supabase ou modificar o código para usar consultas diretas.
- **API do Gemini**: Certifique-se de ter uma chave de API válida do Gemini da xAI. O modelo `ChatGemini` é usado para classificação de intenções e formatação de respostas.
- **LangSmith**: Configure uma conta e projeto no LangSmith para observabilidade. O rastreamento ajuda a depurar fluxos de conversa complexos.
- **Limitações**: O processamento de pagamentos (Pix) e a integração com o WhatsApp estão excluídos conforme suas instruções. O script foca apenas no processamento de mensagens e geração de respostas.
- **Testes**: O exemplo de uso inclui mensagens de teste. Você pode expandir com mais casos de teste com base nas entradas esperadas dos usuários (por exemplo, do documento 09.6).

### Próximos Passos
1. **Configurar Ambiente**: Defina as variáveis de ambiente para LangSmith, Gemini e Supabase.
2. **Configuração do Banco de Dados**: Certifique-se de que o banco de dados Supabase corresponde ao esquema assumido. Crie uma função RPC `execute_sql` se necessário.
3. **Testar o Script**: Execute o exemplo de uso com dados reais ou simulados para verificar o fluxo.
4. **Refinar Prompts**: Ajuste o `intent_prompt` com base em consultas específicas do usuário (por exemplo, dos documentos 09.5 ou 09.6).
5. **Expandir Intenções**: Adicione suporte para fluxos mais complexos (por exemplo, gerenciamento de lista de espera, modificações de reservas) estendendo o grafo.


