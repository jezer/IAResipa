# 01. Atividades de Implementação - Módulo de Resposta ao Usuário

## 1. Visão Geral

Este documento detalha as atividades de desenvolvimento necessárias para implementar a lógica de geração de respostas, conforme descrito nos documentos de objetivo. O foco é a criação dos componentes que interagem com o modelo Gemini para classificar intenções e formatar respostas.

## 2. Atividades

### Atividade 1: Configuração do Cliente e Modelo Gemini

-   **Descrição:** Instanciar o cliente do `ChatGemini` e configurá-lo com as credenciais da API e os parâmetros do modelo (ex: `model="Gemini-3"`).
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:**
    -   O objeto `llm` é criado e está acessível no escopo da aplicação.
    -   As variáveis de ambiente (`Gemini_API_KEY`) são carregadas corretamente.

### Atividade 2: Implementação do Nó de Classificação de Intenção

-   **Descrição:** Criar a função (nó do LangGraph) `classify_intent`.
-   **Lógica:**
    1.  Receber o `state` da conversação.
    2.  Formatar o `intent_prompt` com a mensagem e o telefone do usuário.
    3.  Invocar o modelo `llm` com o prompt formatado.
    4.  Receber a resposta do modelo (string JSON).
    5.  Fazer o parse do JSON para extrair `intent`, `sql_query`, e `response`.
    6.  Implementar o tratamento de erro para falhas no parse do JSON, definindo a intenção como `general_query`.
    7.  Atualizar o `state` com os valores extraídos.
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:**
    -   A função `classify_intent` retorna o estado atualizado com a intenção correta para diferentes entradas de usuário.
    -   O tratamento de erro para JSON inválido funciona como esperado.

### Atividade 3: Implementação do Nó de Formatação de Resposta

-   **Descrição:** Criar a função (nó do LangGraph) `format_response`.
-   **Lógica:**
    1.  Receber o `state` da conversação.
    2.  Verificar se já existe uma resposta no `state`. Se sim, retornar o estado sem modificação.
    3.  Verificar se existe um `sql_result` no `state`.
    4.  Se houver um resultado, formatar o `response_prompt` com a `intent` e o `sql_result`.
    5.  Invocar o modelo `llm` com o prompt de formatação.
    6.  Atualizar o `state` com a resposta em linguagem natural gerada pelo modelo.
    7.  Implementar uma resposta de fallback caso não haja `sql_result` ou resposta pré-definida.
-   **Arquivos Afetados:** O script principal que define o grafo LangGraph.
-   **Critérios de Aceitação:**
    -   A função `format_response` converte com sucesso um resultado de SQL em uma resposta amigável.
    -   A função não sobrescreve respostas já existentes no estado.

### Atividade 4: Implementação das Respostas de Erro e Fallback

-   **Descrição:** Garantir que todos os cenários de erro descritos em `03.general_and_error_responses.md` sejam tratados dentro dos nós apropriados do grafo.
-   **Lógica:**
    -   Adicionar blocos `try...except` nos nós que interagem com serviços externos (Supabase, Gemini).
    -   Em caso de exceção, formatar uma mensagem de erro clara e atualizá-la no `state['response']`.
    -   Garantir que o nó `format_response` tenha uma condição de fallback para o caso de um estado inesperado.
-   **Arquivos Afetados:** Todos os nós do grafo que podem gerar exceções.
-   **Critérios de Aceitação:**
    -   O sistema retorna mensagens de erro informativas em vez de falhar silenciosamente.
    -   O usuário final recebe uma resposta útil mesmo quando ocorrem problemas internos.
