# 02. Criação de Classes de Teste Python (Pytest)

## 1. Estrutura e Nomenclatura

- **Estrutura de Diretórios:** Os testes devem residir em um diretório `tests/` na raiz, espelhando a estrutura do código-fonte (`src/`).
- **Arquivos de Teste:** Devem começar com `test_` (ex: `test_user_model.py`).
- **Classes de Teste:** Devem começar com `Test` (ex: `class TestUserModel:`). Não devem ter um método `__init__`.
- **Funções de Teste:** Devem começar com `test_` (ex: `def test_create_user_successfully():`).

## 2. Princípio do Teste: Setup, Execute, Assert, Teardown

Cada teste deve ser independente e seguir este ciclo:

1.  **Setup (Pré-condições):** Prepare o ambiente para o teste. Use `fixtures` do pytest para criar objetos, conectar a um banco de dados de teste, etc. Garanta que o estado inicial seja limpo e conhecido.
2.  **Execute (Ação):** Chame a função ou método que está sendo testado com os parâmetros definidos no setup.
3.  **Assert (Validações):** Verifique se o resultado da ação é o esperado. Use múltiplas asserções se necessário para validar completamente o estado final.
4.  **Teardown (Limpeza):** As `fixtures` do pytest gerenciam a limpeza automaticamente (ex: fechando conexões de banco, removendo arquivos temporários).

## 3. Fixtures para Setup e Teardown

- Utilize fixtures (`@pytest.fixture`) para preparar o ambiente. Elas são reutilizáveis e tornam os testes mais limpos.
- **Exemplo:**
  ```python
  import pytest

  @pytest.fixture
  def db_connection():
      conn = create_test_db_connection()
      yield conn
      conn.close()

  def test_user_query(db_connection):
      # ... usa a db_connection aqui ...
      pass
  ```

## 4. Gerenciamento de Dados de Teste

- **Dados Simples:** Para dados pequenos e específicos de um teste, declare-os diretamente na função de teste.
- **Dados Complexos/Reutilizáveis:** Armazene dados de teste em arquivos JSON (ex: `test_data.json`) localizados em um diretório `dados/` próximo aos testes que os utilizam. Isso facilita a manutenção e a leitura de cenários complexos.
- **Carregamento:** Crie uma fixture para carregar esses dados JSON, disponibilizando-os para os testes.

## 5. Boas Práticas

- **Independência:** Testes não devem depender uns dos outros. Cada teste deve ser executável de forma isolada.
- **Robustez:** Para operações assíncronas ou que envolvem serviços externos, considere o uso de `mocks` para isolar o teste e garantir sua previsibilidade. Trate exceções esperadas com `pytest.raises`.
- **Reutilização:** Crie funções `helper` para ações de setup ou validações que se repetem em múltiplos testes.
