## Plano para Modularização, Separação de E/S e Testabilidade do Código Python

**Objetivo:** Refatorar a base de código Python em `03.src/resipa/` para melhorar a modularidade, separar a lógica de negócio das operações de E/S (Entrada/Saída) e facilitar o teste unitário.

**Princípios Gerais:**
*   **Princípio da Responsabilidade Única:** Cada módulo/função deve ter uma responsabilidade clara e única.
*   **Injeção de Dependência:** Passar dependências (como cliente Supabase, clientes de API) como argumentos, em vez de importá-las diretamente dentro das funções onde são usadas, especialmente para testabilidade.
*   **Funções Puras:** Buscar funções que, dada a mesma entrada, sempre retornam a mesma saída e não possuem efeitos colaterais (por exemplo, sem E/S direta).
*   **Configuração vs. Lógica:** Separar claramente a configuração (por exemplo, `db_00_supabase_config.py`, `db_00_supabase_schema_config.py`) da lógica de negócio.

### Etapas Específicas de Refatoração:

1.  **Centralizar o Acesso ao Cliente Supabase (Já amplamente feito, mas reforçar):**
    *   Garantir que todos os módulos que precisam de acesso ao Supabase importem e usem `get_supabase_client()` de `resipa.A_db.db_00_supabase_config`.
    *   **Ação:** Revisar `py_01_pix_generator.py`, `py_03_pix_status_checker.py`, `py_04_reservation_manager.py`, `py_05_user_registration_logic.py` para garantir que eles usem `get_supabase_client()` quando sua lógica de placeholder for substituída por interações reais com o Supabase. Por enquanto, esta é uma nota mental para implementação futura.

2.  **Refatorar `py_02_gemini_supabasedb_interface.py`:**
    *   **`query_gemini`:**
        *   **Problema:** Lógica de placeholder.
        *   **Solução:** Ao implementar a integração real da API Gemini, encapsular a lógica de chamada da API em uma classe ou módulo dedicado (por exemplo, `resipa.services.gemini_api_client.py`). A função `query_gemini` em `py_02_gemini_supabasedb_interface.py` chamaria então este serviço. Isso permite mockar o cliente da API Gemini para testes unitários.
    *   **`supabase_crud`:**
        *   **Problema:** `get_supabase_client()` é chamado dentro da função, dificultando o mock do cliente Supabase para testes unitários.
        *   **Solução:** Modificar `supabase_crud` para aceitar uma instância `supabase_client` como argumento. Isso permite injetar um cliente mock durante o teste. A função `main` (ou o código chamador) seria responsável por obter o cliente real via `get_supabase_client()`.
        *   **Ação:** Modificar a assinatura de `supabase_crud` para `def supabase_crud(supabase_client: Client, action: str, table: str, data: dict = None, query: dict = None) -> dict:`. Atualizar todas as chamadas para `supabase_crud` de acordo.

3.  **Refatorar `py_main_processor.py`:**
    *   **Problema:** Acoplamento forte da lógica de roteamento com a análise de `sys.argv` e instruções `print` diretas.
    *   **Solução:**
        *   Criar uma função separada (por exemplo, `process_message(message_details: dict) -> dict`) que contenha a lógica de roteamento principal e chame as funções manipuladoras apropriadas. Esta função deve ser "pura" (sem E/S).
        *   A função `main` seria então responsável por:
            *   Analisar `sys.argv`.
            *   Chamar `process_message`.
            *   Imprimir o resultado.
        *   **Ação:** Implementar `process_message` e refatorar `main` para chamá-la.

4.  **Implementar Lógica Real em Módulos Placeholder (`py_01_pix_generator.py`, `py_03_pix_status_checker.py`, `py_04_reservation_manager.py`, `py_05_user_registration_logic.py`):**
    *   **Problema:** Todas as funções são placeholders.
    *   **Solução:** À medida que a lógica real for implementada, garantir que:
        *   Elas aceitem as dependências necessárias (por exemplo, `supabase_client`, clientes de API) como argumentos.
        *   Elas retornem estruturas de dados que possam ser facilmente verificadas em testes.
        *   Qualquer E/S (como log) seja tratada adequadamente (por exemplo, usando o módulo `logging`, que pode ser configurado/mockado).
    *   **Ação:** Esta é uma tarefa contínua à medida que os recursos são desenvolvidos. Para fins deste plano, o foco é em *como* eles devem ser implementados para testabilidade.

5.  **Introduzir um Subpacote `services` ou `clients` (Opcional, mas Recomendado):**
    *   Para integrações de API externas (Gemini, APIs de pagamento), considerar a criação de um subpacote `resipa.services` ou `resipa.clients`.
    *   Cada serviço externo teria sua própria classe de cliente (por exemplo, `GeminiApiClient`, `PixApiClient`) que lida com as solicitações HTTP reais.
    *   Isso isola ainda mais as dependências externas, tornando-as fáceis de mockar.
    *   **Ação:** Propor isso como uma melhoria futura no documento do plano.

### Estratégia de Teste (Reforçar):

*   **Testes Unitários:** Focar em testar funções/classes individuais isoladamente, mockando dependências externas (cliente Supabase, clientes de API).
*   **Testes de Integração:** Testar a interação entre módulos e com serviços externos reais (Supabase, API Gemini, etc.), conforme já demonstrado com `test_gemini_supabase_interface.py`.
