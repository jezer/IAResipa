
# Visão geral

* Cada agente é **especialista** (perfil próprio) e atua **apenas** numa pasta “atuadora” exclusiva.
* A troca entre agentes ocorre via **pasta compartilhada dedicada** (`shared/agenteX`), com protocolo simples de mensagens.
* Há **perfis de qualidade** (quality profiles) por tipo de entrega **e** um **perfil de qualidade de criação de agentes** (meta-quality) para evitar contradições e manter foco.

# 1) Estrutura de pastas (padrão)

```
/agents/
  agente1/
    inbox/                 # entradas humanas/externas (somente leitura pelo agente)
    outbox/                # saídas finais do agente (único "atuador")
    drafts/                # rascunhos/iteração
    cfg/
      agent.yaml           # identidade + escopo + restrições + roteamento
      profile_quality.yaml # quality do perfil do agente (ex.: Arquitetura, Negócio, Dev)
      prompts.md           # instruções longas e exemplos (com front-matter YAML)
    logs/
  agente2/
    ...
/shared/
  agente1/                 # canal de troca assíncrona p/ agente1 (inbox/outbox virtuais)
  agente2/
  bus/                     # opcional: fila comum para broadcast/eventos
/scripts/
  lint_agent.py            # validação agent.yaml / prompts
  lint_quality.py          # validação de perfis de qualidade
  route_guard.py           # verificação de escopo + roteamento (rejeita/indica agente)
```

# 2) Formato do arquivo para diálogo e configuração

**Recomendação híbrida (mais produtiva):**

* **`prompts.md`** com **YAML front-matter** para metadados (+ corpo em Markdown para instruções extensas, exemplos, few-shots).
* **`agent.yaml`** para configuração rígida (identidade, escopo, restrições, canais, políticas de roteamento).

> Por quê?
>
> * YAML é ótimo para **máquina** (lint/CI, chaves claras).
> * Markdown é ótimo para **humano** (legível, exemplos ricos).
> * Front-matter permite “um arquivo” quando preferir simplicidade — mas separar `agent.yaml` mantém governança limpa.

Se precisar **apenas** de um arquivo: use **`prompts.md`** com **front-matter YAML** (a “Opção 1: front-matter” que você já considerou).

# 3) Perfil de Qualidade por perfil (quality profile)

Cada especialidade (Negócio, Arquitetura, Dev, Testes, UX) tem seu **`profile_quality.yaml`** com:

* **Objetivo de qualidade** (o que otimiza).
* **Critérios “must”** (bloqueadores).
* **Critérios “should”** (recomendados).
* **Checklists automáticas** (regras que o lint valida).
* **Limite de profundidade** (para evitar “qualidade da qualidade”: níveis S, A, B — ver abaixo).

### Exemplo (profile\_quality.yaml – “Arquitetura”)

```yaml
profile: Arquitetura
target: "Metas claras, diagramas, limites de contexto, trade-offs."
must:
  - "Sem contradição entre escopo, restrições e entregáveis."
  - "Explicar trade-offs e impacto em custo/risco."
  - "Indicar limites de contexto e roteamento de fora de escopo."
should:
  - "Fornecer estrutura de pastas e versionamento."
  - "Sugerir automações (lint, CI) para manter padrão."
limits:
  depth_tier: "A"   # S (máx), A (alto), B (básico)
lint_rules:
  - id: ARCH-CTX-001
    description: "Todo documento deve declarar contexto e anti-objetivos."
    check: "frontmatter.has('context') && frontmatter.has('anti_goals')"
  - id: ARCH-ROUTE-002
    description: "Definir agente alternativo ao recusar fora-de-escopo."
    check: "yaml.agent.routing.out_of_scope_handling == true"
```

> **Níveis de qualidade (para limitar excesso):**
>
> * **S (máx):** projetos críticos (auditoria, regulação, alto risco).
> * **A (alto):** padrão do time; bom equilíbrio.
> * **B (básico):** rascunhos/POCs; checagens mínimas.

# 4) Perfil de Qualidade para **criação de agentes** (meta-quality)

Arquivo único em `/policies/agent_creation_quality.yaml`:

```yaml
policy: AgentCreation
must:
  - "Nome único e descritivo."
  - "Escopo explícito (inclui e exclui)."
  - "Restrições claras (dados, ética, custo, tempo)."
  - "Pasta atuadora única definida (ex.: agents/agenteX/outbox)."
  - "Canal de troca configurado (shared/agenteX)."
  - "Agente de apoio (mentor/validador) nomeado."
  - "Roteamento fora-de-escopo definido (lista de agentes alternativos)."
  - "Sem conflitos com agentes existentes (nomes, escopos sobrepostos sem regra)."
should:
  - "Exemplos positivos/negativos de tarefas."
  - "Métricas de sucesso (KPIs) e limites de custo/tempo."
lint_rules:
  - id: ACRT-UNI-001
    description: "Nome e path exclusivos."
  - id: ACRT-SCOPE-002
    description: "Escopo inclui anti-goals."
  - id: ACRT-ROUTE-003
    description: "Definido fallback de roteamento OOS."
```

# 5) Rejeição fora de escopo + indicação de agente

Política uniforme (implementada em `route_guard.py` e declarada no `agent.yaml`):

**Fluxo:**

1. Agente avalia `is_in_scope(task)`.
2. Se **não** estiver no escopo:

   * **Rejeita** com mensagem padrão curta.
   * **Indica** 1–2 agentes candidatos (do `routing.fallbacks`) e opcionalmente **posta um card** em `/shared/<agenteSugerido>/` com o contexto.

**Mensagem padrão (curta):**

> “Pedido fora do meu escopo (**<motivo>**). Sugiro o **<agente>** para **\<razão>**.”

### Trecho de `agent.yaml` (roteamento)

```yaml
name: "agente1"
scope:
  include: ["regras de negócio", "políticas de uso", "fluxos de autorização"]
  exclude: ["código", "infra", "testes automatizados"]
restrictions:
  data: ["sem PII em texto livre", "usar apenas fontes aprovadas"]
actuator: "agents/agente1/outbox"
shared_channel: "shared/agente1"
routing:
  out_of_scope_handling: true
  fallbacks:
    - agent: "agente2_arquitetura"
      reason: "Desenho de solução e trade-offs técnicos"
    - agent: "agente3_dev"
      reason: "Implementação em código"
```

# 6) Protocolo de troca em `/shared/agenteX`

Formato simples **YAML-envelope** + conteúdo Markdown:

```
/shared/agente2/2025-08-18T12-03-22Z_req_from_agente1.yaml
---
type: "assist_request"
from: "agente1"
to:   "agente2"
topic: "Validação de trade-offs"
related_files:
  - "agents/agente1/drafts/solucao_X.md"
deadline_minutes: 30
---
[Markdown com contexto resumido + perguntas objetivas]
```

Respostas:

```
/shared/agente1/2025-08-18T12-10-05Z_resp_from_agente2.yaml
---
type: "assist_response"
from: "agente2"
to:   "agente1"
status: "done"   # done | need_more_info | rejected
---
[Conclusões + bullets acionáveis]
```

# 7) Templates (prontos para uso)

### `agents/agente1/cfg/agent.yaml`

```yaml
name: "agente1_negocio"
owner: "time_negocio"
quality_tier: "A"  # S | A | B
scope:
  include: ["objetivos", "regras de negócio", "políticas de uso", "fluxos de agendamento"]
  exclude: ["infraestrutura", "código backend", "testes automatizados"]
restrictions:
  - "Não gerar código."
  - "Não alterar políticas sem aprovação."
actuator: "agents/agente1/outbox"
shared_channel: "shared/agente1"
support_agent: "agente2_arquitetura"
routing:
  out_of_scope_handling: true
  fallbacks:
    - agent: "agente2_arquitetura"
      reason: "Arquitetura e integração Supabase/Google Sites"
    - agent: "agente3_dev"
      reason: "Python/JS e automações n8n"
kpis:
  - "tempo_resposta_ms <= 3000"
  - "contradicoes == 0"
```

### `agents/agente1/cfg/prompts.md` (com front-matter)

```markdown
---
role: "Especialista em Negócio"
tone: "objetivo e direto"
context: "Agendamentos (quiosques/quadras), Supabase, Google Sites, Python, JS"
anti_goals:
  - "Escrever código"
  - "Definir arquitetura de infraestrutura"
guardrails:
  reject_out_of_scope: true
  always_route_to: ["agente2_arquitetura", "agente3_dev"]
examples:
  positive:
    - user: "Um usuário pode reservar 2 quiosques no mesmo mês?"
      assistant: "Não. Política XYZ. Alternativas: lista de espera ou troca de titularidade."
  negative:
    - user: "Implemente o endpoint em Python"
      assistant: "[FORA DE ESCOPO] Sugiro agente3_dev."
---
## Instruções
1) Responder apenas sobre objetivos, regras, políticas e fluxos de uso.
2) Manter linguagem simples e bullets acionáveis.
3) Se detectar lacuna, pedir a mínima info necessária.
```

# 8) Lints e checagens (automatizáveis)

* **`lint_agent.py`**

  * Valida esquema YAML (chaves obrigatórias: name/scope/actuator/shared\_channel/routing).
  * Confere exclusividade de `actuator`.
  * Garante que `exclude` existe e não conflita com `include`.
  * Busca sobreposição de escopos entre agentes (avisa ou bloqueia).
* **`lint_quality.py`**

  * Verifica `must` cobertos no `prompts.md` (front-matter).
  * Aplica **limits.depth\_tier** (S/A/B) para modular o rigor.
  * Checa presença de **anti\_goals** e **roteamento OOS**.

# 9) Política de recusa (padrão curtinha)

> **Padrão**: “**Fora do meu escopo**: *<motivo curto>*. **Procure** *<agente>* (*\<razão>*). Se quiser, envio um pedido para ele.”
> Opcional: criar automaticamente o `assist_request` em `/shared/<agente>`.

---

## Decisão rápida sobre formatos

* **Se quer velocidade e simplicidade**: **apenas `prompts.md` com front-matter YAML** (uma peça por agente).
* **Se quer governança e escalabilidade**: **`agent.yaml` + `prompts.md`** (separados) + `profile_quality.yaml` por perfil + política global de criação de agentes.

